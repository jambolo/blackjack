# analyze-kings-bounty.coffee
#
# Computes the expected value of the King's Bounty side bet by simulating a large number of rounds.
#
# King's Bounty pays when the player's first two cards total 20. Various combinations of cards pay different amounts.
#
# The payout table is as follows:
#
#   Kings of Spades + BJ  1,000 to 1
#   Kings of Spades         100 to 1
#   Suited Kings             30 to 1
#   Suited Q/J/10            20 to 1
#   Suited 20                 9 to 1
#   Kings                     6 to 1
#   Unsuited 20               4 to 1
#   Other                    -1 to 1
#
# Note: Kings of Spades + BJ is simulated by assuming that some fraction of the time the dealer will have a
# blackjack according to the data generated by generate-dealer-blackjack-probabilities.coffee

fs = require 'fs'
{
  DECK_SIZE
  COUNT_RANGE_PER_DECK
  ACE
  JACK
  QUEEN
  KING
  BUST
  LOW_CARDS
  UNCOUNTED_CARDS
  HIGH_CARDS
  NUMBER_OF_SUITS
  DEFAULT_CONFIGURATION
  countValueOf
  valueOf
} = require './common'

NUMBER_OF_SHOES = 10000000
DECKS_PER_SHOE = DEFAULT_CONFIGURATION.DECKS_PER_SHOE
PENETRATION = DEFAULT_CONFIGURATION.PENETRATION
CARDS_TO_DEAL_PER_SHOE = (DECKS_PER_SHOE - PENETRATION) * DECK_SIZE

PAYOUTS =
  'Kings of Spades + BJ': 1000
  'Kings of Spades': 100
  'Suited Kings': 30
  'Suited Q/J/10': 20
  'Suited 20': 9
  'Unsuited Kings': 6
  'Unsuited 20': 4
  'Other': -1

shuffle = (shoe) ->
  i = shoe.length
  while --i > 0
    j = ~~(Math.random() * (i + 1))
    [shoe[i], shoe[j]] = [shoe[j], shoe[i]]
  return

cardDensitiesByCount = JSON.parse(fs.readFileSync('data/cardDensitiesByCount.json'))
COUNT_RANGE = (cardDensitiesByCount.length - 1) / 2

countIndex = (c) -> c + COUNT_RANGE

TEN_COUNT_RANGE = 4 * NUMBER_OF_SUITS * DECKS_PER_SHOE
KING_COUNT_RANGE = NUMBER_OF_SUITS * DECKS_PER_SHOE

# Probability of a dealer blackjack by count.
dealerBlackjackProbabilitiesByCount = []
for count in [-COUNT_RANGE .. COUNT_RANGE]
  i = countIndex(count)
  p10 = 0
  for c in HIGH_CARDS
    p10 += cardDensitiesByCount[i][c]
  dealerBlackjackProbabilitiesByCount.push cardDensitiesByCount[i][ACE] * p10

# Outcome frequencies by count.
frequenciesByCount = (
  {
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0
  } for [-COUNT_RANGE .. COUNT_RANGE]
)

# Outcome frequencies by 10 count.
frequenciesByTenCount =
  {
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0
  } for [0 .. TEN_COUNT_RANGE]

# Outcome frequencies by king count.
frequenciesByKingCount =
  {
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0
  } for [0 .. KING_COUNT_RANGE]

# Total outcome frequencies.
frequencies =
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0

countFrequencies = (0 for [-COUNT_RANGE .. COUNT_RANGE])
tenCountFrequencies = (0 for [0 .. TEN_COUNT_RANGE])
kingCountFrequencies = (0 for [0 .. KING_COUNT_RANGE])

numberOfHands = 0 # Total number of hands dealt.

console.log "Simulating #{NUMBER_OF_SHOES} shoes..."

for i in [0 ... NUMBER_OF_SHOES]
  console.log "#{(i / NUMBER_OF_SHOES * 100).toFixed(0)}% of #{NUMBER_OF_SHOES}" if i % (NUMBER_OF_SHOES / 10) == 0

  # Suit is i % 4, rank is i / 4 + 1
  shoe = []
  shoe = shoe.concat [0 ... DECK_SIZE] for [0 ... DECKS_PER_SHOE]
  shuffle shoe

  # Deal hands until the penetration limit is reached, accumulating the outcomes by count
  runningCount = 0
  runningTenCount = TEN_COUNT_RANGE
  runningKingCount = KING_COUNT_RANGE
  c = 0
  while c <= CARDS_TO_DEAL_PER_SHOE
    # Get the true count for the next hand.
    trueCount = Math.round(runningCount / ((shoe.length - c) / DECK_SIZE))
    i = countIndex(trueCount)
    countFrequencies[i]++

    # Get the true 10 count for the next hand.
    trueTenCount = Math.round(runningTenCount / ((shoe.length - c) / DECK_SIZE))
    tenCountFrequencies[trueTenCount]++

    # Get the true king count for the next hand.
    trueKingCount = Math.round(runningKingCount / ((shoe.length - c) / DECK_SIZE))
    kingCountFrequencies[trueKingCount]++

    # Deal the next hand.
    bottom = shoe[c++]
    bottomSuit = bottom % NUMBER_OF_SUITS
    bottomRank = Math.floor(bottom / NUMBER_OF_SUITS) + 1
    runningCount += countValueOf(bottomRank)
    runningTenCount-- if bottomRank >= 10
    runningKingCount-- if bottomRank == KING

    top = shoe[c++]
    topSuit = top % NUMBER_OF_SUITS
    topRank = Math.floor(top / NUMBER_OF_SUITS) + 1
    runningCount += countValueOf(topRank)
    runningTenCount-- if topRank >= 10
    runningKingCount-- if topRank == KING

    numberOfHands++

    # Determine outcome
    hand = [bottomRank, topRank]
    if valueOf(hand) == 20
      if bottomSuit == topSuit
        if bottomRank == topRank
          if topRank == KING
            if bottomSuit == 0 and topSuit == 0
              if dealerBlackjackProbabilitiesByCount[i] > Math.random()
                outcome = 'Kings of Spades + BJ'
              else
                outcome = 'Kings of Spades'
            else
              outcome = 'Suited Kings'
          else # Suited and the same rank, but not kings
            outcome = 'Suited Q/J/10'
        else # Suited but the same rank (includes ACE and 9)
          outcome = 'Suited 20'
      else # Unsuited
        if bottomRank == KING and topRank == KING # Unsuited Kings
          outcome = 'Unsuited Kings'
        else # Unsuited but 20
          outcome = 'Unsuited 20'
    else # Loser
      outcome = 'Other'

    frequencies[outcome]++
    frequenciesByCount[i][outcome]++
    frequenciesByTenCount[trueTenCount][outcome]++
    frequenciesByKingCount[trueKingCount][outcome]++

console.log "Number of hands: #{numberOfHands}"

totalPayout = 0
totalOccurrence = 0
frequenciesTable = []
for hand, n of frequencies
  payout = PAYOUTS[hand] * n
  frequenciesTable.push
    'Hand': hand
    'Occurrence %': parseFloat((n / numberOfHands * 100).toFixed(4))
    'Payout': parseFloat((payout / numberOfHands * 100).toFixed(4))
  totalPayout += payout
  totalOccurrence += n
frequenciesTable.push
  'Hand': 'Total'
  'Occurrence %': parseFloat((totalOccurrence / numberOfHands * 100).toFixed(4))
  'Payout': parseFloat((totalPayout / numberOfHands).toFixed(4))

console.table frequenciesTable

frequenciesByCountTable = []
for count in [-20 .. 20]
  i = countIndex(count)
  if countFrequencies[i] > 0
    entry = { 'Count': count }
    totalPayout = 0
    totalOccurrence = 0
    for hand, n of frequenciesByCount[i]
      entry[hand] = parseFloat((n / countFrequencies[i] * 100).toFixed(4))
      totalPayout += PAYOUTS[hand] * n
    entry['Total Payout'] = parseFloat((totalPayout / countFrequencies[i]).toFixed(4))
    frequenciesByCountTable.push entry

console.table frequenciesByCountTable

frequenciesByTenCountTable = []
for count in [0 .. TEN_COUNT_RANGE]
  if tenCountFrequencies[count] > 0
    entry = { '10 Count': count }
    totalPayout = 0
    totalOccurrence = 0
    for hand, n of frequenciesByTenCount[count]
      entry[hand] = parseFloat((n / tenCountFrequencies[count] * 100).toFixed(4))
      totalPayout += PAYOUTS[hand] * n
    entry['Total Payout'] = parseFloat((totalPayout / tenCountFrequencies[count]).toFixed(4))
    frequenciesByTenCountTable.push entry

console.table frequenciesByTenCountTable

frequenciesByKingCountTable = []
for count in [0 .. KING_COUNT_RANGE]
  if kingCountFrequencies[count] > 0
    entry = { 'King Count': count }
    totalPayout = 0
    totalOccurrence = 0
    for hand, n of frequenciesByKingCount[count]
      entry[hand] = parseFloat((n / kingCountFrequencies[count] * 100).toFixed(4))
      totalPayout += PAYOUTS[hand] * n
    entry['Total Payout'] = parseFloat((totalPayout / kingCountFrequencies[count]).toFixed(4))
    frequenciesByKingCountTable.push entry

console.table frequenciesByKingCountTable
