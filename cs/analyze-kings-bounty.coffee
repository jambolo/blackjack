# analyze-kings-bounty.coffee
#
# Computes the expected value of the King's Bounty side bet by simulating a large number of rounds.
#
# King's Bounty pays when the player's first two cards total 20. Various combinations of cards pay different amounts.
#
# The payout table is as follows:
#
#   Kings of Spades + BJ  1,000 to 1
#   Kings of Spades         100 to 1
#   Suited Kings             30 to 1
#   Suited Q/J/10            20 to 1
#   Suited 20                 9 to 1
#   Kings                     6 to 1
#   Unsuited 20               4 to 1
#   Other                    -1 to 1
#
# Note: Kings of Spades + BJ is simulated by assuming that some fraction of the time the dealer will have a
# blackjack according to the data generated by generate-dealer-blackjack-probabilities.coffee

fs = require 'fs'
{
  DECK_SIZE
  COUNT_RANGE_PER_DECK
  ACE
  JACK
  QUEEN
  KING
  BUST
  LOW_CARDS
  UNCOUNTED_CARDS
  HIGH_CARDS
  NUMBER_OF_SUITS
  DEFAULT_CONFIGURATION
  countValueOf
  valueOf
} = require './common'

NUMBER_OF_SHOES = 1000#0000
DECKS_PER_SHOE = DEFAULT_CONFIGURATION.DECKS_PER_SHOE
PENETRATION = DEFAULT_CONFIGURATION.PENETRATION
CARDS_TO_DEAL_PER_SHOE = (DECKS_PER_SHOE - PENETRATION) * DECK_SIZE

PAYOUTS =
  'Kings of Spades + BJ': 1000
  'Kings of Spades': 100
  'Suited Kings': 30
  'Suited Q/J/10': 20
  'Suited 20': 9
  'Unsuited Kings': 6
  'Unsuited 20': 4
  'Other': -1

shuffle = (shoe) ->
  i = shoe.length
  while --i > 0
    j = ~~(Math.random() * (i + 1))
    [shoe[i], shoe[j]] = [shoe[j], shoe[i]]
  return

cardDensitiesByCount = JSON.parse(fs.readFileSync('data/cardDensitiesByCount.json'))
COUNT_RANGE = (cardDensitiesByCount.length - 1) / 2

countIndex = (c) -> c + COUNT_RANGE

TEN_COUNT_RANGE = 4 * NUMBER_OF_SUITS * DECKS_PER_SHOE
KING_COUNT_RANGE = NUMBER_OF_SUITS * DECKS_PER_SHOE

# Probability of a dealer blackjack by count.
dealerBlackjackProbabilitiesByCount = []
for count in [-COUNT_RANGE .. COUNT_RANGE]
  i = countIndex(count)
  p10 = 0
  for c in HIGH_CARDS
    p10 += cardDensitiesByCount[i][c]
  dealerBlackjackProbabilitiesByCount.push cardDensitiesByCount[i][ACE] * p10

# Outcome frequencies by count.
frequenciesByCount = (
  {
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0
  } for [-COUNT_RANGE .. COUNT_RANGE]
)

# Outcome frequencies by 10 count.
frequenciesByTenCount =
  {
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0
  } for [0 .. TEN_COUNT_RANGE]

# Outcome frequencies by king count.
frequenciesByKingCount =
  {
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0
  } for [0 .. KING_COUNT_RANGE]

# Total outcome frequencies.
frequencies =
    'Kings of Spades + BJ': 0
    'Kings of Spades': 0
    'Suited Kings': 0
    'Suited Q/J/10': 0
    'Suited 20': 0
    'Unsuited Kings': 0
    'Unsuited 20': 0
    'Other': 0

countFrequencies = (0 for [-COUNT_RANGE .. COUNT_RANGE])
tenCountFrequencies = (0 for [0 .. TEN_COUNT_RANGE])
kingCountFrequencies = (0 for [0 .. KING_COUNT_RANGE])

# Total returns per hand played for all combinations of counts
# FYI: referenced as returns[trueCount][trueTenCount][trueKingCount]
returns = ((([0, 0] for [0 .. KING_COUNT_RANGE]) for [0 .. TEN_COUNT_RANGE]) for [-COUNT_RANGE .. COUNT_RANGE])

numberOfHands = 0 # Total number of hands dealt.

# Accumulate returns for a hand.
accumulateHandPayout = (outcome, count, tenCount, kingCount) ->
  if true#count >= 6 and tenCount >= 18 and kingCount >= 6
    for cc in [-COUNT_RANGE .. count]
      ii = countIndex(cc)
      for tt in [0 .. tenCount]
        for kk in [0 .. kingCount]
          returns[ii][tt][kk][0] += PAYOUTS[outcome]
          returns[ii][tt][kk][1]++

console.log "Simulating #{NUMBER_OF_SHOES} shoes..."

for i in [0 ... NUMBER_OF_SHOES]
  console.log "#{(i / NUMBER_OF_SHOES * 100).toFixed(0)}% of #{NUMBER_OF_SHOES}" if i % (NUMBER_OF_SHOES / 10) == 0

  # Suit is i % 4, rank is i / 4 + 1
  shoe = []
  shoe = shoe.concat [0 ... DECK_SIZE] for [0 ... DECKS_PER_SHOE]
  shuffle shoe

  # Deal hands until the penetration limit is reached, accumulating the outcomes by count
  runningCount = 0
  runningTenCount = TEN_COUNT_RANGE
  runningKingCount = KING_COUNT_RANGE
  c = 0
  while c <= CARDS_TO_DEAL_PER_SHOE
    # Get the true count for the next hand.
    trueCount = Math.round(runningCount / ((shoe.length - c) / DECK_SIZE))
    i = countIndex(trueCount)
    countFrequencies[i]++

    # Get the true 10 count for the next hand.
    trueTenCount = Math.round(runningTenCount / ((shoe.length - c) / DECK_SIZE))
    tenCountFrequencies[trueTenCount]++

    # Get the true king count for the next hand.
    trueKingCount = Math.round(runningKingCount / ((shoe.length - c) / DECK_SIZE))
    kingCountFrequencies[trueKingCount]++

    # Deal the next hand.
    bottom = shoe[c++]
    bottomSuit = bottom % NUMBER_OF_SUITS
    bottomRank = Math.floor(bottom / NUMBER_OF_SUITS) + 1
    runningCount += countValueOf(bottomRank)
    runningTenCount-- if bottomRank >= 10
    runningKingCount-- if bottomRank == KING

    top = shoe[c++]
    topSuit = top % NUMBER_OF_SUITS
    topRank = Math.floor(top / NUMBER_OF_SUITS) + 1
    runningCount += countValueOf(topRank)
    runningTenCount-- if topRank >= 10
    runningKingCount-- if topRank == KING

    numberOfHands++

    # Determine outcome
    hand = [bottomRank, topRank]
    if valueOf(hand) == 20
      if bottomSuit == topSuit
        if bottomRank == topRank
          if topRank == KING
            if bottomSuit == 0 and topSuit == 0
              if dealerBlackjackProbabilitiesByCount[i] > Math.random()
                outcome = 'Kings of Spades + BJ'
              else
                outcome = 'Kings of Spades'
            else
              outcome = 'Suited Kings'
          else # Suited and the same rank, but not kings
            outcome = 'Suited Q/J/10'
        else # Suited but the same rank (includes ACE and 9)
          outcome = 'Suited 20'
      else # Unsuited
        if bottomRank == KING and topRank == KING # Unsuited Kings
          outcome = 'Unsuited Kings'
        else # Unsuited but 20
          outcome = 'Unsuited 20'
    else # Loser
      outcome = 'Other'

    frequencies[outcome]++
    frequenciesByCount[i][outcome]++
    frequenciesByTenCount[trueTenCount][outcome]++
    frequenciesByKingCount[trueKingCount][outcome]++

    # Accumulate returns
    accumulateHandPayout outcome, trueCount, trueTenCount, trueKingCount

console.log "Number of hands: #{numberOfHands}"

totalPayout = 0
totalOccurrence = 0
frequenciesTable = []
for hand, n of frequencies
  payout = PAYOUTS[hand] * n
  frequenciesTable.push
    'Hand': hand
    'Frequency (%)': parseFloat((n / numberOfHands * 100).toFixed(4))
    'Payout': parseFloat((payout / numberOfHands).toFixed(4))
  totalPayout += payout
  totalOccurrence += n
frequenciesTable.push
  'Hand': 'Total'
  'Frequency (%)': parseFloat((totalOccurrence / numberOfHands * 100).toFixed(4))
  'Payout': parseFloat((totalPayout / numberOfHands).toFixed(4))

console.table frequenciesTable

## Find the boundaries of the return table in which the return is not negative.
#minCount = do ->
#  for c in [-COUNT_RANGE .. COUNT_RANGE]
#    i = countIndex(c)
#    for t in [0 .. TEN_COUNT_RANGE]
#      for k in [0 .. KING_COUNT_RANGE]
#        if returns[i][t][k][0] > 0
#          return c
#  return COUNT_RANGE
#maxCount = do ->
#  for c in [COUNT_RANGE .. -COUNT_RANGE]
#    i = countIndex(c)
#    for t in [0 .. TEN_COUNT_RANGE]
#      for k in [0 .. KING_COUNT_RANGE]
#        if returns[i][t][k][0] > 0
#          return c
#  return -COUNT_RANGE
#minTenCount = do ->
#  for t in [0 .. TEN_COUNT_RANGE]
#    for c in [-COUNT_RANGE .. COUNT_RANGE]
#      i = countIndex(c)
#      for k in [0 .. KING_COUNT_RANGE]
#        if returns[i][t][k][0] > 0
#          return t
#  return TEN_COUNT_RANGE
#maxTenCount = do ->
#  for t in [TEN_COUNT_RANGE .. 0]
#    for c in [-COUNT_RANGE .. COUNT_RANGE]
#      i = countIndex(c)
#      for k in [0 .. KING_COUNT_RANGE]
#        if returns[i][t][k][0] > 0
#          return t
#  return 0
#minKingCount = do ->
#  for k in [0 .. KING_COUNT_RANGE]
#    for c in [-COUNT_RANGE .. COUNT_RANGE]
#      i = countIndex(c)
#      for t in [0 .. TEN_COUNT_RANGE]
#        if returns[i][t][k][0] > 0
#          return k
#  return KING_COUNT_RANGE
#maxKingCount = do ->
#  for k in [KING_COUNT_RANGE .. 0]
#    for c in [-COUNT_RANGE .. COUNT_RANGE]
#      i = countIndex(c)
#      for t in [0 .. TEN_COUNT_RANGE]
#        if returns[i][t][k][0] > 0
#          return k
#  return 0
#
#console.log("ðŸš€ ~ minCount:", minCount)
#console.log("ðŸš€ ~ maxCount:", maxCount)
#console.log("ðŸš€ ~ minTenCount:", minTenCount)
#console.log("ðŸš€ ~ maxTenCount:", maxTenCount)
#console.log("ðŸš€ ~ minKingCount:", minKingCount)
#console.log("ðŸš€ ~ maxKingCount:", maxKingCount)
#
## Find the location of the maximum return.
#best = -Infinity
#bestCount = 0
#bestTenCount = 0
#bestKingCount = 0
#for c in [-COUNT_RANGE .. COUNT_RANGE]
#  i = countIndex(c)
#  for t in [0 .. TEN_COUNT_RANGE]
#    for k in [0 .. maxKingCount]
#      if returns[i][t][k][0] > best
#        best = returns[i][t][k][0]
#        bestCount = c
#        bestTenCount = t
#        bestKingCount = k
#
#console.log "Maximum return:"
#console.log "  when count >= #{bestCount}, 10-count >= #{bestTenCount}, king-count >= #{bestKingCount}"
#console.log "    overall: #{best / numberOfHands}"
#console.log "    per bet : #{best / returns[countIndex(bestCount)][bestTenCount][bestKingCount][1]}"

#frequenciesByCountTable = []
#for count in [-20 .. 20]
#  i = countIndex(count)
#  if countFrequencies[i] > 0
#    entry = { 'Count': count }
#    totalPayout = 0
#    totalOccurrence = 0
#    for hand, n of frequenciesByCount[i]
#      entry[hand] = parseFloat((n / countFrequencies[i] * 100).toFixed(4))
#      totalPayout += PAYOUTS[hand] * n
#    entry['Total Payout'] = parseFloat((totalPayout / countFrequencies[i]).toFixed(4))
#    frequenciesByCountTable.push entry
#
#console.table frequenciesByCountTable
#
#frequenciesByTenCountTable = []
#for count in [0 .. TEN_COUNT_RANGE]
#  if tenCountFrequencies[count] > 0
#    entry = { '10 Count': count }
#    totalPayout = 0
#    totalOccurrence = 0
#    for hand, n of frequenciesByTenCount[count]
#      entry[hand] = parseFloat((n / tenCountFrequencies[count] * 100).toFixed(4))
#      totalPayout += PAYOUTS[hand] * n
#    entry['Total Payout'] = parseFloat((totalPayout / tenCountFrequencies[count]).toFixed(4))
#    frequenciesByTenCountTable.push entry
#
#console.table frequenciesByTenCountTable
#
#frequenciesByKingCountTable = []
#for count in [0 .. KING_COUNT_RANGE]
#  if kingCountFrequencies[count] > 0
#    entry = { 'King Count': count }
#    totalPayout = 0
#    totalOccurrence = 0
#    for hand, n of frequenciesByKingCount[count]
#      entry[hand] = parseFloat((n / kingCountFrequencies[count] * 100).toFixed(4))
#      totalPayout += PAYOUTS[hand] * n
#    entry['Total Payout'] = parseFloat((totalPayout / kingCountFrequencies[count]).toFixed(4))
#    frequenciesByKingCountTable.push entry
#
#console.table frequenciesByKingCountTable
